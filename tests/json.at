# Checking the satyr. -*- Autotest -*-

AT_BANNER([JSON parser])

## ---------------------- ##
## sr_json_valid_toplevel ##
## ---------------------- ##

AT_TESTFUN([sr_json_valid_toplevel],
[[
#include "json.h"
#include <assert.h>
#include <string.h>

int
main(void)
{
  char *error_message = NULL;
  struct sr_json_value *value = NULL;

  /* The null value */
  value = sr_json_parse("\nnull\n\n", &error_message);
  assert(value != NULL);
  assert(error_message == NULL);
  assert(value->type == SR_JSON_NULL);
  sr_json_value_free(value);

  /* Boolean true */
  value = sr_json_parse("\ntrue\n\n", &error_message);
  assert(value != NULL);
  assert(error_message == NULL);
  assert(value->type == SR_JSON_BOOLEAN);
  assert(value->u.boolean == 1);
  sr_json_value_free(value);

  /* Boolean false */
  value = sr_json_parse("\n\t\tfalse", &error_message);
  assert(value != NULL);
  assert(error_message == NULL);
  assert(value->type == SR_JSON_BOOLEAN);
  assert(value->u.boolean == 0);
  sr_json_value_free(value);

  /* Empty string */
  value = sr_json_parse("\n\"\"\n\n", &error_message);
  assert(value != NULL);
  assert(error_message == NULL);
  assert(value->type == SR_JSON_STRING);
  assert(value->u.string.length == 0);
  sr_json_value_free(value);

  /* Integer zero */
  value = sr_json_parse("\n0\n\n", &error_message);
  assert(value != NULL);
  assert(error_message == NULL);
  assert(value->type == SR_JSON_INTEGER);
  sr_json_value_free(value);

  /* Floating-point zero */
  value = sr_json_parse("\n0.0\n\n", &error_message);
  assert(value != NULL);
  assert(error_message == NULL);
  assert(value->type == SR_JSON_DOUBLE);
  sr_json_value_free(value);

  /* Empty array */
  value = sr_json_parse("[\n\n]\n", &error_message);
  assert(value != NULL);
  assert(error_message == NULL);
  assert(value->type == SR_JSON_ARRAY);
  assert(value->u.array.length == 0);
  sr_json_value_free(value);

  /* Empty object */
  value = sr_json_parse("\n{  }\n\n", &error_message);
  assert(value != NULL);
  assert(error_message == NULL);
  assert(value->type == SR_JSON_OBJECT);
  assert(value->u.object.length == 0);
  sr_json_value_free(value);

  return 0;
}
]])

## -------------------- ##
## sr_json_valid_object ##
## -------------------- ##

AT_TESTFUN([sr_json_valid_object],
[[
#include "json.h"
#include <assert.h>
#include <string.h>

int
main(void)
{
  char *error_message = NULL;
  struct sr_json_value *value = NULL, *child = NULL;

  /* Object with some doubles */
  value = sr_json_parse("{ \"min\": -1.0e+28, \"max\": 1.0e+28 }\n\n", &error_message);
  assert(value != NULL);
  assert(error_message == NULL);
  assert(value->type == SR_JSON_OBJECT);
  assert(value->u.object.length == 2);

  assert(value->u.object.values[0].name != NULL);
  assert(strcmp(value->u.object.values[0].name, "min") == 0);
  child = value->u.object.values[0].value;
  assert(child != NULL);
  assert(child->type == SR_JSON_DOUBLE);
  assert(child->u.dbl == -1.0e+28);

  assert(value->u.object.values[1].name != NULL);
  assert(strcmp(value->u.object.values[1].name, "max") == 0);
  child = value->u.object.values[1].value;
  assert(child != NULL);
  assert(child->type == SR_JSON_DOUBLE);
  assert(child->u.dbl == 1.0e+28);

  sr_json_value_free(value);

  return 0;
}
]])

## ------------------- ##
## sr_json_valid_array ##
## ------------------- ##

AT_TESTFUN([sr_json_valid_array],
[[
#include "json.h"
#include <assert.h>
#include <string.h>

int
main(void)
{
  char *error_message = NULL;
  struct sr_json_value *value = NULL;

  /* Array with a bunch of integers */
  value = sr_json_parse("[ 44, 55223,\n  8931, -432,\n 311 ]\n", &error_message);
  assert(value != NULL);
  assert(error_message == NULL);
  assert(value->type == SR_JSON_ARRAY);
  assert(value->u.array.length == 5);

  assert(value->u.array.values[0]->type == SR_JSON_INTEGER);
  assert(value->u.array.values[0]->u.integer == 44);

  assert(value->u.array.values[1]->type == SR_JSON_INTEGER);
  assert(value->u.array.values[1]->u.integer == 55223);

  assert(value->u.array.values[2]->type == SR_JSON_INTEGER);
  assert(value->u.array.values[2]->u.integer == 8931);

  assert(value->u.array.values[3]->type == SR_JSON_INTEGER);
  assert(value->u.array.values[3]->u.integer == -432);

  assert(value->u.array.values[4]->type == SR_JSON_INTEGER);
  assert(value->u.array.values[4]->u.integer == 311);

  sr_json_value_free(value);

  /* Array with two Booleans and a UTF-8-encoded string */
  value = sr_json_parse("[ true, false, \"\\u20AC\\u20AD\" ]", &error_message);
  assert(value != NULL);
  assert(error_message == NULL);
  assert(value->type == SR_JSON_ARRAY);
  assert(value->u.array.length == 3);

  assert(value->u.array.values[0]->type == SR_JSON_BOOLEAN);
  assert(value->u.array.values[0]->u.boolean == 1);

  assert(value->u.array.values[1]->type == SR_JSON_BOOLEAN);
  assert(value->u.array.values[1]->u.boolean == 0);

  assert(value->u.array.values[2]->type == SR_JSON_STRING);
  assert(value->u.array.values[2]->u.string.length == 6);
  assert(strcmp(value->u.array.values[2]->u.string.ptr,
    "\xe2\x82\xac\xe2\x82\xad") == 0);

  sr_json_value_free(value);

  /* Array with a bunch of doubles */
  value = sr_json_parse("[0.4e004, 0.8e-006, 0.4e+009, 4e006, 2e-006,  1e+0011 ]\n",
    &error_message);
  assert(value != NULL);
  assert(error_message == NULL);
  assert(value->type == SR_JSON_ARRAY);
  assert(value->u.array.length == 6);

  assert(value->u.array.values[0]->type == SR_JSON_DOUBLE);
  assert(value->u.array.values[0]->u.dbl == 4e3);

  assert(value->u.array.values[1]->type == SR_JSON_DOUBLE);
  assert(value->u.array.values[1]->u.dbl == 8e-7);

  assert(value->u.array.values[2]->type == SR_JSON_DOUBLE);
  assert(value->u.array.values[2]->u.dbl == 4e8);

  assert(value->u.array.values[3]->type == SR_JSON_DOUBLE);
  assert(value->u.array.values[3]->u.dbl == 4e6);

  assert(value->u.array.values[4]->type == SR_JSON_DOUBLE);
  assert(value->u.array.values[4]->u.dbl == 2e-6);

  assert(value->u.array.values[5]->type == SR_JSON_DOUBLE);
  assert(value->u.array.values[5]->u.dbl == 1e11);

  sr_json_value_free(value);

  return 0;
}
]])

## --------------- ##
## sr_json_invalid ##
## --------------- ##

AT_TESTFUN([sr_json_invalid],
[[
#include "json.h"
#include <assert.h>
#include <stdlib.h>
#include <string.h>

/* Note: Square brackets are sometimes written as \x5b and \x5d to circumvent
 * M4's quoting rules and so that the program is a valid input for the preprocessor
 */

int
main(void)
{
  char *error_message = NULL;
  struct sr_json_value *value = NULL;

  /* Empty input is not allowed */
  value = sr_json_parse("", &error_message);
  assert(value == NULL);
  assert(strcmp(error_message, "Line 1, column 0: Empty input") == 0);
  free(error_message);

  /* Mismatched closing bracket */
  value = sr_json_parse("\x5d", &error_message);
  assert(value == NULL);
  assert(strcmp(error_message, "Line 1, column 0: Unexpected `\x5d`") == 0);
  free(error_message);

  /* Mismatched opening bracket */
  value = sr_json_parse("\x5b", &error_message);
  assert(value == NULL);
  assert(strcmp(error_message, "Line 1, column 1: Unexpected EOF") == 0);
  free(error_message);

  /* Mismatched quote */
  value = sr_json_parse("\x5b true, null, \"unfinished string  ", &error_message);
  assert(value == NULL);
  assert(strcmp(error_message, "Line 1, column 34: Unexpected EOF in string") == 0);
  free(error_message);

  /* Mismatched bracket reprise */
  value = sr_json_parse("[ 92219, true ]\x5b", &error_message);
  assert(value == NULL);
  assert(strcmp(error_message, "Line 1, column 15: Trailing garbage: `\x5b`") == 0);
  free(error_message);

  /* Mismatched bracket for objects */
  value = sr_json_parse(" {}\n} ", &error_message);
  assert(value == NULL);
  assert(strcmp(error_message, "Line 2, column 1: Trailing garbage: `}`") == 0);
  free(error_message);

  /* Garbage in between */
  value = sr_json_parse("{\"hello\": \"world\", \"value\": null, true, \"key\": 15}",
    &error_message);
  assert(value == NULL);
  assert(strcmp(error_message, "Line 1, column 34: Unexpected `t` in object") == 0);
  free(error_message);

  /* Leading zeros are not allowed */
  value = sr_json_parse("[ 0311 ]",
    &error_message);
  assert(value == NULL);
  assert(strcmp(error_message, "Line 1, column 3: Unexpected `0` before `3`") == 0);
  free(error_message);

  /* Incomplete input */
  value = sr_json_parse("\x5b\nnull,\nfal",
    &error_message);
  assert(value == NULL);
  assert(strcmp(error_message, "Line 3, column 1: Unknown value") == 0);
  free(error_message);

  return 0;
}
]])
